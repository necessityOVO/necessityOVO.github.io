<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>grid（网格）布局</title>
      <link href="/2020/09/30/4.grid-wang-ge-bu-ju/"/>
      <url>/2020/09/30/4.grid-wang-ge-bu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="grid（网格）布局"><a href="#grid（网格）布局" class="headerlink" title="grid（网格）布局"></a>grid（网格）布局</h1><h6 id="参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html"><a href="#参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html" class="headerlink" title="参考链接 http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html"></a>参考链接 <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></h6><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a><code>display</code></h3><p>采用网格(grid)布局<br>==注意==: 设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><ul><li><code>grid</code>：块级容器</li><li><code>inline-grid</code>：行内容器</li></ul><h3 id="grid-auto-columns-rows"><a href="#grid-auto-columns-rows" class="headerlink" title="grid-auto-columns / rows"></a><code>grid-auto-columns / rows</code></h3><ul><li>设置自动创建的多余网格的列宽和行高</li></ul><h3 id="grid-template-rows-columns"><a href="#grid-template-rows-columns" class="headerlink" title="grid-template-rows / columns"></a><code>grid-template-rows / columns</code></h3><ul><li><p>指定行列宽度</p><ul><li><p>用像素或百分比</p><pre><code>grid-template-rows: 100px 100px 100px;grid-template-columns: 33.3% 33.3% 33.3%;</code></pre></li><li><p>repeat()</p><pre><code>  grid-template-rows: repeat（3,100px）</code></pre></li><li><p>auto-fill</p><pre><code>grid-template-columns: repeat(auto-fill, 100px);</code></pre></li><li><p>fr单位(既fraction)</p><pre><code>grid-template-columns: 1fr 1fr;</code></pre></li><li><p>minmax(min, max)</p></li></ul></li><li><p>网格线名称</p><p>注意三行应制定四行网格线</p><ul><li>[name]</li></ul></li></ul><h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a><code>grid-template-areas</code></h3><ul><li>定义区域，名字即为网格网格名</li></ul><pre><code>    grid-template-areas: 'a b c'                               'd e f'                               'g h i';</code></pre><p>  不要利用的区域用”点”(.)表示<br>  注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h3 id="grid-row-column-gap"><a href="#grid-row-column-gap" class="headerlink" title="grid-row / column-gap"></a><code>grid-row / column-gap</code></h3><p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><ul><li><p>指定行列的间距</p></li><li><p>合并写法</p><ul><li><code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</code></li><li><code>gap: &lt;row-gap&gt; &lt;column-gap&gt;;</code></li></ul></li></ul><h3 id="grid-auto-flow-先行后列"><a href="#grid-auto-flow-先行后列" class="headerlink" title="grid-auto-flow  先行后列"></a><code>grid-auto-flow</code>  先行后列</h3><ul><li><p>row / column</p><ul><li><p>不考虑空位，保证先后顺序</p><ul><li>链接：<a href="https://jsbin.com/wapejok/edit?css,output">https://jsbin.com/wapejok/edit?css,output</a></li></ul></li></ul></li><li><p>row dense / column dense</p><ul><li><p>尽量紧密排列</p><ul><li>链接：<a href="https://jsbin.com/xutokec/edit?css,output">https://jsbin.com/xutokec/edit?css,output</a></li></ul></li></ul></li></ul><h3 id="单元格内容的位置"><a href="#单元格内容的位置" class="headerlink" title="单元格内容的位置"></a>单元格内容的位置</h3><ul><li><code>align-items</code> 垂直方向</li><li><code>justify-items</code> 水平方向</li><li>合并写法: <code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><h3 id="项目整体在容器内的位置"><a href="#项目整体在容器内的位置" class="headerlink" title="项目整体在容器内的位置"></a>项目整体在容器内的位置</h3><ul><li><p><code>justify-content</code> 水平方向</p></li><li><p><code>align-content</code> 垂直方向</p></li><li><p><code>place-content</code>  前两个的合并写法</p><ul><li><code>place-content: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul></li></ul><hr><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="指定项目位置"><a href="#指定项目位置" class="headerlink" title="指定项目位置"></a>指定项目位置</h3><ul><li><p><code>grid-row / column-start / end</code></p><ul><li><p>写法</p><ul><li>网格线数字</li><li>网格线名字</li><li>span：num</li><li>重叠了用<code>z-index</code></li></ul></li><li><p>简写</p><ul><li><code>grid-row / column: &lt;start-line&gt; / &lt;end-line&gt;</code></li></ul></li></ul></li></ul><h3 id="指定项目区域名"><a href="#指定项目区域名" class="headerlink" title="指定项目区域名"></a>指定项目区域名</h3><ul><li><code>grid-area: 区域名</code></li></ul><h3 id="单元格内容的位置-优先"><a href="#单元格内容的位置-优先" class="headerlink" title="单元格内容的位置(优先)"></a>单元格内容的位置(优先)</h3><ul><li><code>align-self</code> 垂直方向</li><li><code>justify-self</code> 水平方向</li><li>合并写法: <code>place-self: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><p><img src="../images/4.%20%20grid%EF%BC%88%E7%BD%91%E6%A0%BC%EF%BC%89%E5%B8%83%E5%B1%80.png" alt="思维导图"></p><p>&lt;%- image_tag(‘../images/4.%20%20grid（网格）布局.png’, [options]) %&gt;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2020/09/30/3.git-chang-yong-ming-ling/"/>
      <url>/2020/09/30/3.git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h5 id="集中式和分布式版本控制系统的区别"><a href="#集中式和分布式版本控制系统的区别" class="headerlink" title="集中式和分布式版本控制系统的区别"></a>集中式和分布式版本控制系统的区别</h5><blockquote><p>分布式版本控制系统：每个开发者都有整个代码库的所有版本，在离线状态下开发者可以进行版本管理开发, 等网络恢复再push到仓库中。</p></blockquote><blockquote><p>集中式版本控制系统：每个开发者只有应用代码库的一个版本，在离线状态下开发者无法进行版本管理开发。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="Git 工作区、暂存区和版本库"></p><ol><li><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6></li></ol><p><code>git init</code>:初始化仓库<br><code>git status</code> : 查看状态：红色表示在工作区，绿色表示在暂存区，其他在版本区<br><code>git add 文件名</code>  :工作区添加到暂存区，”.”号表所有<br><code>git commit -m '注释'</code> : 暂存区到版本区<br><code>git clone URL</code> : 克隆仓库<br><code>git remote add 别名 URL</code>: 本地仓库关联远程仓库,别名一般用origin<br><code>git remote remove 别名</code>: 本地仓库移除关联</p><ol start="2"><li><h6 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h6></li></ol><p><code>git checkout 分支</code> : 切换分支<br><code>git checkout -b 分支</code> : 创建并切换<br><code>git branch 分支</code> : 创建分支但不切换<br><code>git branch</code>: 查看分支列表<br><code>git checkout -d 分支</code> : 删除分支<br><code>git push origin 分支</code> : 分支推送远程<br><code>git pull origin 分支</code> : 远程拉取到本地<br><code>git fetch origin master:tmp</code>: 新建一个tmp分支，将远程仓库的master分支上代码版本复制到tmp分支上，不会自动合并<br><code>git merge 分支</code> : 指定分支合并到当前分支</p><ol start="3"><li><h6 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h6><p><code>git log</code>: 提交日志<br><code>git reflog</code>: 每次提交的ID<br><code>git reset --hard HEAD^</code>: 版本回退到一个版本，”^“回退一个版本，”^^”回退两个版本<br><code>git reset --hard ID号</code>:回退到指定版本</p></li><li><h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p><code>git rm 文件名</code>: 删除指定文件<br><code>git rm -r 文件名</code>: 删除指定文件夹<br><code>git rm --cached 文件</code>: 从暂存区删除 </p></li><li><h6 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h6></li></ol><p><code>git diff</code> : 比较暂存区与工作区<br><code>git diff --cached</code> : 比较版本区与暂存区<br><code>git diff master</code> : 比较版本区与工作区<br><code>git diff branch1 branch2</code>:显示出两个分支之间所有有差异的文件的详细差异<br><code>git diff branch1 branch2 --stat</code>:显示出两个分支之间所有有差异的文件列表<br><code>git diff branch1 branch2 xxx</code>:显示指定文件的详细差异</p><ol><li><h6 id="基础Linux命令"><a href="#基础Linux命令" class="headerlink" title="基础Linux命令"></a>基础Linux命令</h6></li></ol><p><code>mkdir</code> :创建文件夹<br><code>vi</code> : 创建文件并进入<br><code>i</code> :编辑模式<br><code>ESC+:+wq</code> : 保存并退出<br><code>ESC+:+q!</code> : 不保存并退出<br><code>cd</code> : 进入文件夹<br><code>ls</code> : 当前文件夹文件列表<br><code>pwd</code> : 当前目录<br><code>cat</code> 文件 : 显示文件内容<br><code>clear</code> : 清屏</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>betterScroll踩坑记录</title>
      <link href="/2020/09/20/1betterscroll-cai-keng-ji-lu/"/>
      <url>/2020/09/20/1betterscroll-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用BetterScroll刚<code>npm run serve</code>时无法进行滑动，需要修改BetterScroll的源码，<br>   修改<code>BetterSC/shared-utils/src/dom.ts</code> 中的常量hasTouch为true,<br>   这样就可以在初始化时对参数进行设置,把一切掌握在自己手中</p><p>   使用方法如下:</p><pre><code> new BScroll时,在参数options中加入 mouseWheel: true,   //开启鼠标滚轮 disableMouse: false,   //启用鼠标拖动 disableTouch: false    //启用手指触摸</code></pre><p>   参考博客：<a href="https://www.cnblogs.com/mldonkey/p/11421577.html">https://www.cnblogs.com/mldonkey/p/11421577.html</a></p></li></ol><ol start="2"><li>使用BetterScroll后绑定scroll, click事件后无法触发，也无报错<br> BetterScroll默认拦截了click事件可在<code>new Bscroll()</code>的配置对象中传入<code> click: true</code></li><li>使用BetterScroll的<code>scroll</code>事件必须同时在<code>new Bscroll()</code>配置对象中指定<code>probeType</code> </li></ol><p><img src="../images/1.1.jpg" alt="what"></p><p>(后面发现官网都有说明… 链接：<a href="https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F">https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F</a>)</p><p><img src="../images/1.2.jpg" alt="what"></p><p>. 使用better-scroll时注意$nextTick的使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue动态路由引入和异步组件记录</title>
      <link href="/2020/09/20/2.vue-router-dong-tai-lu-you/"/>
      <url>/2020/09/20/2.vue-router-dong-tai-lu-you/</url>
      
        <content type="html"><![CDATA[<p>动态引入的路由组件在打包时路由组件会被单独打包(代码分割 code split),<br>默认不请求加载路由组件打包文件, 当请求需要路由组件时才请求加载,当引入需要的的组件时在<code>Network</code>会增加一个打包文件(一般为<code>/^\d+.js$/</code>格式)。</p><h4 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h4><ul><li><p>component是一个执行就会<code>import()</code>的函数</p><pre><code>myComponent =  () =&gt; import(path)</code></pre></li><li><p>将组件定义对象(component definition)传递给 <code>resolve</code> 回调函数</p><pre><code>Vue.component(component, (resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve({      template: YourTemplate    })  }, 100)})</code></pre></li><li><p>使用<code>require</code>引入，这个特殊的 require 语法将指示 webpack 自动将构建后的代码，拆分到不同的 bundle 中，然后通过 Ajax 请求加载。</p><pre><code>Vue.component(component, (resolve) =&gt; {  setTimeOut(() =&gt; {    require(path, resolve);  }, 100)})</code></pre></li><li><p>使用返回的<code>promise</code>resolve前<code>import</code></p><pre><code>- Vue.component(component, (resolve) =&gt; {    setTimeOut(() =&gt; {      import(path).then(resolve);    }, 100)  })- Vue.component(component, Promise.resolve(template对象))- Vue.component(component, Promise.resolveDelay(template对象, time))</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

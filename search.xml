<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js设计模式</title>
      <link href="/2020/10/16/5.js-she-ji-mo-shi/"/>
      <url>/2020/10/16/5.js-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h2><blockquote><p><font color="brown"><strong>重中之重！！！：找出变化的地方，使变化的地方与不变的地方分离</strong></font></p></blockquote><h3 id="1-单例模式-singleton"><a href="#1-单例模式-singleton" class="headerlink" title="1. 单例模式 singleton"></a><strong>1. 单例模式 singleton</strong></h3><ol><li><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p></li><li><p>实现：用变量标志当前的是否已经为该类创造过实例对象，如果创造过则直接返回该实例，否则创造一个实例返回</p><pre class=" language-JavaScript"><code class="language-JavaScript">    let getSingle = (function() {        let instance;        return function (fn, ...rest) {     //fn: 用于创建单例的类            return instance || instance = fn.apply(this, rest);        }    })()</code></pre></li><li><p>惰性单例：在需要时才创建实例对象</p></li></ol><h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a><strong>2.代理模式</strong></h3><blockquote><p>当客户不方便直接访问一个对象，或者不满足需要的时候，提供一个替身对象让客户访问，替身对请求进行一些处理后再把请求转交给本体对象</p></blockquote><img src="/archives/2020/10/16/5.js-she-ji-mo-shi/hengBlog\source\images\5.代理模式.png" alt="5.代理模式" style="zoom: 25%;"><p><strong>注意</strong>：<strong>代理对象和本体对象的接口应一致</strong>，让客户使用代理对象，这个方便本体和代理使用的替换</p><ul><li><p>保护代理：用于过滤一些请求的代理</p></li><li><p>虚拟代理：选择在合适的时机处理请求的代理</p></li><li><p>缓存代理：使用代理暂时缓存远算结果，下次运算先在缓存容器里读取，没有再计算</p></li><li><p>其他代理：防火墙代理，远程代理，保护代理，智能引用代理，写时复制代理</p></li></ul><h3 id="3-发布订阅模式-PubSub"><a href="#3-发布订阅模式-PubSub" class="headerlink" title="3.发布订阅模式(PubSub)"></a><strong>3.发布订阅模式(PubSub)</strong></h3><ol><li><p>定义：又叫观察者模式，定义对象间的一种一对多的依赖关系，当对象改变时，所有依赖它的对象都会得到通知</p></li><li><p>实现：</p><ul><li>首先指定好谁充当发布者</li><li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</li><li>发布消息时，发布者遍历这个列表，依次触发存放的订阅者的回调函数</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//订阅的通用实现</span><span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token punctuation">{</span>         clientList<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 缓存列表</span>        listen<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> key<span class="token punctuation">,</span> fn <span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//订阅函数， key用来判断发布者发布的事件是否是订阅者所希望收到订阅的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> fn <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 订阅的消息添加进缓存列表</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            trigger<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 发布函数</span>                <span class="token keyword">var</span> key <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">,</span>                 fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span> key <span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>fns <span class="token operator">||</span> fns<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没有绑定对应的消息</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> fns<span class="token punctuation">[</span> i<span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// arguments 是trigger 时带上的参数</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> installEvent <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token keyword">in</span> event <span class="token punctuation">)</span><span class="token punctuation">{</span>                obj<span class="token punctuation">[</span> i <span class="token punctuation">]</span> <span class="token operator">=</span> event<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//个人认为应还应判断是否有重名方法</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取消订阅的通用实现</span>event<span class="token punctuation">.</span>remove <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果key 对应的消息没有被人订阅，则直接返回</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果没有传入具体的回调函数，表示需要取消key 对应消息的所有订阅</span>      fns<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> l <span class="token operator">=</span> fns<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> l <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> l<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 反向遍历订阅的回调函数列表, 需要取消订阅的一般靠后，从后面开始遍历性能更好</span>            <span class="token keyword">var</span> _fn <span class="token operator">=</span> fns<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_fn <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>                fns<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除订阅者的回调函数</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ol><blockquote><p>缺点：</p><ul><li>创建订阅者本身要消耗一定的时间和内存，特别是订阅的消息一直未触发发布时，但这个订阅者会始终存在于内存中</li><li>发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解</li></ul></blockquote><blockquote><p>GitHub库：<a href="https://github.com/mroderick/PubSubJS">https://github.com/mroderick/PubSubJS</a></p></blockquote><h3 id="4-策略模式strategy"><a href="#4-策略模式strategy" class="headerlink" title="4. 策略模式strategy"></a>4. 策略模式strategy</h3><blockquote><p>个人理解： 将一个对象(事物, 情景)的不同情况都封装为方法，再在不同情况下去调用对应的方法</p></blockquote><ol><li>定义：将不同情况的解决办法定义为函数，并用对象封装起来，不同情况调用不同函数</li><li>目的：使算法的<strong>使用</strong>和<strong>实现</strong>分离，内部实现其功能，用户只用关心使用</li><li>组成：<ul><li>策略类strategy： 封装了解决不同情况的对个算法(函数), 负责计算具体过程</li><li>环境类context：接收用户的请求，并将请求委托(分发)给对应的策略，因此需要维持对策略类的引用</li></ul></li><li>典例：表单验证</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http:// xxx.com/register<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>registerForm<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            请输入用户名:&lt;input type="text" name="userName"/ > 请输入密码:&lt;input            type="text" name="password"/ > 请输入手机号码:&lt;input type="text"            name="phoneNumber"/ >            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">/***********************策略对象**************************/</span>            <span class="token keyword">var</span> strategies <span class="token operator">=</span> <span class="token punctuation">{</span>                isNonEmpty<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 传入表单值</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                minLength<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> length<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                isMobile<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex">/(^1[3|5|8][0-9]{9}$)/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***********************Validator 类**************************/</span>            <span class="token keyword">var</span> Validator <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 将需检查的规则全部缓存，不用考虑顺序</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 添加需检查的规则列表</span>            Validator<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>dom<span class="token punctuation">,</span> rules<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rule<span class="token punctuation">;</span> <span class="token punctuation">(</span>rule <span class="token operator">=</span> rules<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>rule<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 为什么需要闭包？</span>                        <span class="token keyword">var</span> strategyAry <span class="token operator">=</span> rule<span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> rule<span class="token punctuation">.</span>errorMsg<span class="token punctuation">;</span>                        self<span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//缓存规则检查前的信息加工函数</span>                            <span class="token keyword">var</span> strategy <span class="token operator">=</span> strategyAry<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            strategyAry<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>dom<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                            strategyAry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">return</span> strategies<span class="token punctuation">[</span>strategy<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> strategyAry<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 依次调用cache的函数进行检查</span>            Validator<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> validatorFunc<span class="token punctuation">;</span><span class="token punctuation">(</span>validatorFunc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> <span class="token function">validatorFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***********************客户调用代码**************************/</span>            <span class="token keyword">var</span> registerForm <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"registerForm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> validataFunc <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> validator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Validator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 添加检查需检查的表单项</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>userName<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span> strategy<span class="token punctuation">:</span> <span class="token string">"isNonEmpty"</span><span class="token punctuation">,</span> errorMsg<span class="token punctuation">:</span> <span class="token string">"用户名不能为空"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>                        strategy<span class="token punctuation">:</span> <span class="token string">"minLength:6"</span><span class="token punctuation">,</span>                        errorMsg<span class="token punctuation">:</span> <span class="token string">"用户名长度不能小于 10 位"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>password<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span>                        strategy<span class="token punctuation">:</span> <span class="token string">"minLength:6"</span><span class="token punctuation">,</span>                        errorMsg<span class="token punctuation">:</span> <span class="token string">"密码长度不能小于 6 位"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                validator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registerForm<span class="token punctuation">.</span>phoneNumber<span class="token punctuation">,</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span> strategy<span class="token punctuation">:</span> <span class="token string">"isMobile"</span><span class="token punctuation">,</span> errorMsg<span class="token punctuation">:</span> <span class="token string">"手机号码格式不正确"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> validator<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> errorMsg<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//绑定表单验证的事件</span>            registerForm<span class="token punctuation">.</span>onsubmit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> errorMsg <span class="token operator">=</span> <span class="token function">validataFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">alert</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="5-迭代器模式"><a href="#5-迭代器模式" class="headerlink" title="5.迭代器模式"></a>5.迭代器模式</h3><blockquote><p>与策略模式的对比：策略模式的各种策略是自己已知的，而迭代器模式所需要元素是未知的，通过迭代后才能确定</p></blockquote><p>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露对象的内部表示</p><p>分类：</p><ul><li>内部迭代器：规则隐藏在内部，外部不可见，缺点就是迭代规则不可控，交互只在第一次初始调用，</li><li>外部迭代器：迭代规则可手工控制，使迭代器更灵活，但调用也跟复杂了</li><li>倒序迭代器：从后面往前遍历的迭代器</li></ul><h3 id="6-命令模式"><a href="#6-命令模式" class="headerlink" title="6.命令模式"></a>6.命令模式</h3><blockquote><p>个人理解： 将执行的方法与执行的本体对象分离</p></blockquote><p>没有接收者的智能命令，和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图的不同。</p><p>策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标 的不同手段，它们的内部实现是针对“算法”而言的。</p><p>而智能命令模式指向的问题域更广，command 对象解决的目标更具发散性</p><h3 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7.组合模式"></a>7.组合模式</h3><p>定义：用小的子对象来构建更大的对象，而这些子对象本身也有更小的孙对象构成</p><p>优点：</p><ul><li>用树形结构表示“部分-整体”的层次结构</li><li>通过对象的多态性，使用户对单个对象和组合对象的使用具有一致性(既方法名一样)</li></ul><p>注意：</p><ul><li>组合模式不是父子关系，只是组合对象把请求委托给叶子对象(类似职责链模式)</li><li>组合对象和叶子对象，叶子对象之间都必须是相同的接口，</li><li>组合对象和子对象为双向映射，一对一的关系，不能给同一个叶子对象两次请求委托</li></ul><p>缺点：</p><ul><li>系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解</li><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起</li></ul><h3 id="8-模板方法模式"><a href="#8-模板方法模式" class="headerlink" title="8.模板方法模式"></a>8.模板方法模式</h3><blockquote><p>个人理解：不变的封装到父类，可变的封装到子类</p></blockquote><p>在 JavaScript 中, 我们很多时候都不需要依样画瓢地去实现一个模版方法模式，<strong>高阶函数是更好的选择</strong></p><h3 id="9-享元模式"><a href="#9-享元模式" class="headerlink" title="9.享元模式"></a>9.享元模式</h3><blockquote><p>个人理解：一段逻辑本来需要许多重复或相似的对象，但只使用一个对象(带有内部状态)当做模板，每次使用时再包装(传入外部状态)成所需要的对象来达到效果</p></blockquote><p>关键是<strong>如何划分内部状态和外部状态</strong>：</p><ul><li>内部状态存储于对象内部</li><li>内部状态可以被一些对象共享</li><li>内部状态独立于具体的场景，通常不会改变</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li></ul><p>例子：文件上传</p><pre class=" language-JavaScript"><code class="language-JavaScript">    Upload.prototype.delFile = function( id ){ // 文件删除函数        uploadManager.setExternalState( id, this );         if ( this.fileSize < 3000 ){            return this.dom.parentNode.removeChild( this.dom );        }        if ( window.confirm( '确定要删除该文件吗? ' + this.fileName ) ){            return this.dom.parentNode.removeChild( this.dom );        }    }    //实例化上传对象    var UploadFactory = (function(){        var createdFlyWeightObjs = {};        return {            create: function( uploadType){                 if ( createdFlyWeightObjs [ uploadType] ){  // 单例模式                    return createdFlyWeightObjs [ uploadType];                }                return createdFlyWeightObjs [ uploadType] = new Upload( uploadType);            }        }    })();    // 用统一的管理器封装外部状态    var uploadManager = (function(){        var uploadDatabase = {};        return {            add: function( id, uploadType, fileName, fileSize ){                var flyWeightObj = UploadFactory.create( uploadType );                var dom = document.createElement( 'div' );                dom.innerHTML =                '<span>文件名称:'+ fileName +', 文件大小: '+ fileSize +'</span>' +                '<button class="delFile">删除</button>';                dom.querySelector( '.delFile' ).onclick = function(){                    flyWeightObj.delFile( id );                }                document.body.appendChild( dom );                uploadDatabase[ id ] = {                    fileName: fileName,                    fileSize: fileSize,                    dom: dom                };                return flyWeightObj ;            },            setExternalState: function( id, flyWeightObj ){                var uploadData = uploadDatabase[ id ];                  for ( var i in uploadData ){        // 包装(传入外部状态)成所需要的对象                    flyWeightObj[ i ] = uploadData[ i ];                }            }        }    })();    // 触发开始上传的函数    var id = 0;    window.startUpload = function( uploadType, files ){        for ( var i = 0, file; file = files[ i++ ]; ){            var uploadObj = uploadManager.add( ++id, uploadType, file.fileName, file.fileSize );        }    };</code></pre><p>使用场景：</p><ul><li><p>一个程序中使用了大量的相似对象</p></li><li><p>由于使用了大量对象，造成很大的内存开销</p></li><li><p>对象的大多数状态都可以变为外部状态</p></li><li><p>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象</p></li></ul><h3 id="10-职责链模式"><a href="#10-职责链模式" class="headerlink" title="10.职责链模式"></a>10.职责链模式</h3><p>定义：将多个对象连成一条链，若处理不了就将请求向下传递，直到有一个对象能处理，它避免请求对象与多个处理对象之间耦合的局面</p><p>优点：</p><ul><li>解耦了请求发送者和 N 个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可</li><li>链中的节点对象可以灵活地拆分重组</li><li>可以手动指定起始节点</li></ul><p>缺点</p><ul><li>需要在最后添加错误处理节点，以防没有成功处理请求的节点</li><li>可能存在多余的节点并未使用</li></ul><h3 id="11-中介者模式"><a href="#11-中介者模式" class="headerlink" title="11.中介者模式"></a>11.中介者模式</h3><blockquote><p>个人理解：让多个对象之间的相互联系变成多个对象只与中介者联系，由中介者统一进行管理，如vuex</p></blockquote><img src="/archives/2020/10/16/5.js-she-ji-mo-shi/hengBlog\source\images\5.中介者模式.png" style="zoom: 33%;"><p>优点：</p><ul><li>解耦对象之间的紧密关系</li><li>使对象间多对多的关系变成一对多关系</li></ul><h3 id="12-装饰者模式"><a href="#12-装饰者模式" class="headerlink" title="12.装饰者模式"></a>12.装饰者模式</h3><blockquote><p>可以配合AOP实现多个函数方法的整体化，又类似适配器模式，可以在外层包装一层函数进行装饰。值得注意的是，它并不会更改原对象</p></blockquote><p>定义： 给对象动态的增加职责(方法)</p><p>例子：AOP装饰函数</p><pre class=" language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> beforefn <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存原函数的引用</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 返回包含了原函数和新函数的"代理"函数</span>        beforefn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 执行新函数，可在此处修改参数arguments</span>        <span class="token keyword">return</span> __self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行原函数并返回原函数的执行结果，并且保证this 不被劫持</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> afterfn <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> ret <span class="token operator">=</span> __self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>        afterfn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>值得注意的是：</p><ul><li>因为函数通过 <code>Function.prototype.before</code> 或者 <code>Function.prototype.after</code> 被装 饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失</li><li>装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些 影响</li></ul><p>代理模式和装饰者模式的区别：<strong>在于它们的意图和设计目的</strong>。</p><ul><li><p>代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。代理模式强调一种关系(Proxy 与它的实体之间的关系)，这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而且代理模式通常只有一层代理本体的引用</p></li><li><p>装饰者模式的作用就是为对象动态加入行为，用于一开始不能确定对象的全部功能时。而且装饰者模式经常会形成一条长长的装饰链</p></li></ul><h3 id="13-状态模式"><a href="#13-状态模式" class="headerlink" title="13.状态模式"></a>13.状态模式</h3><p>定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p><p>应用关键：区别事物上下文(context)内部的状态，事物<strong>内部状态的改变</strong>往往会带来事物的<strong>行为改变</strong>，把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部</p><p>优点：</p><ul><li>状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换方法</li><li>避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li><li>Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响</li></ul><p>缺点：</p><ul><li>会在系统中定义许多状态类，枯燥乏味，而且系统中会因此而增加不少对象</li><li>由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑</li></ul><p><strong>状态模式和策略模式的关系</strong>：</p><p>相同点：它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行</p><p>区别：策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， 所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法;    而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。</p><h3 id="14-适配器模式"><a href="#14-适配器模式" class="headerlink" title="14.适配器模式"></a>14.适配器模式</h3><p>应用：解决两个软件实体的接口不兼容的问题</p><p>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</p><h2 id="二、设计原则"><a href="#二、设计原则" class="headerlink" title="二、设计原则"></a>二、设计原则</h2><h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则(SRP)"></a>1.单一职责原则(SRP)</h3><p>定义：一个类应该仅有一个引起它变化的原因, 既一个对象或方法只做一件事情</p><p>分离原则：</p><ul><li>如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们(比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开。)</li><li>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。</li></ul><h3 id="2-最少知识原则-LKP"><a href="#2-最少知识原则-LKP" class="headerlink" title="2.最少知识原则(LKP)"></a>2.最少知识原则(LKP)</h3><p>定义：一个软件实体应当尽量少的与其他实体发生作用，既减少交互，减少耦合</p><h3 id="3-开放-封闭原则-OCP"><a href="#3-开放-封闭原则-OCP" class="headerlink" title="3.开放-封闭原则(OCP)"></a>3.开放-封闭原则(OCP)</h3><p>定义：软件实体(类，模块，函数等)应该是能扩展，但是不可修改的</p><h2 id="三、代码重构建议"><a href="#三、代码重构建议" class="headerlink" title="三、代码重构建议"></a>三、代码重构建议</h2><ol><li>提炼函数，及时添加注释，不要让函数过长</li><li>合并重复的条件片段</li><li>将条件分支语句提炼成函数</li><li>合理的使用循环，递归</li><li>使用return提前让条件退出以代替嵌套的条件分支(小技巧：即在面对一个嵌套的 if 分支时，我们可以把外层 if 表达式进行反转，就能转化为多个并级的条件判断语句)</li><li>传递对象参数以代替过长的参数列表</li><li>尽量减少参数数量</li><li>尽量不要用嵌套的三目运算符，该为if</li><li>合理使用链式调用(原理：方法结束后对象返回自身)</li><li>分解大型类为多个小类</li><li>使用return退出多重循环</li><li></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript, 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grid（网格）布局</title>
      <link href="/2020/09/30/4.grid-wang-ge-bu-ju/"/>
      <url>/2020/09/30/4.grid-wang-ge-bu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="grid（网格）布局"><a href="#grid（网格）布局" class="headerlink" title="grid（网格）布局"></a>grid（网格）布局</h1><h6 id="参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html"><a href="#参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html" class="headerlink" title="参考链接 http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html"></a>参考链接 <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></h6><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a><code>display</code></h3><p>采用网格(grid)布局<br>==注意==: 设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><ul><li><code>grid</code>：块级容器</li><li><code>inline-grid</code>：行内容器</li></ul><h3 id="grid-auto-columns-rows"><a href="#grid-auto-columns-rows" class="headerlink" title="grid-auto-columns / rows"></a><code>grid-auto-columns / rows</code></h3><ul><li>设置自动创建的多余网格的列宽和行高</li></ul><h3 id="grid-template-rows-columns"><a href="#grid-template-rows-columns" class="headerlink" title="grid-template-rows / columns"></a><code>grid-template-rows / columns</code></h3><ul><li><p>指定行列宽度</p><ul><li><p>用像素或百分比</p><pre><code>grid-template-rows: 100px 100px 100px;grid-template-columns: 33.3% 33.3% 33.3%;</code></pre></li><li><p>repeat()</p><pre><code>  grid-template-rows: repeat（3,100px）</code></pre></li><li><p>auto-fill</p><pre><code>grid-template-columns: repeat(auto-fill, 100px);</code></pre></li><li><p>fr单位(既fraction)</p><pre><code>grid-template-columns: 1fr 1fr;</code></pre></li><li><p>minmax(min, max)</p></li></ul></li><li><p>网格线名称</p><p>注意三行应制定四行网格线</p><ul><li>[name]</li></ul></li></ul><h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a><code>grid-template-areas</code></h3><ul><li>定义区域，名字即为网格网格名</li></ul><pre><code>    grid-template-areas: 'a b c'                               'd e f'                               'g h i';</code></pre><p>  不要利用的区域用”点”(.)表示<br>  注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h3 id="grid-row-column-gap"><a href="#grid-row-column-gap" class="headerlink" title="grid-row / column-gap"></a><code>grid-row / column-gap</code></h3><p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><ul><li><p>指定行列的间距</p></li><li><p>合并写法</p><ul><li><code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</code></li><li><code>gap: &lt;row-gap&gt; &lt;column-gap&gt;;</code></li></ul></li></ul><h3 id="grid-auto-flow-先行后列"><a href="#grid-auto-flow-先行后列" class="headerlink" title="grid-auto-flow  先行后列"></a><code>grid-auto-flow</code>  先行后列</h3><ul><li><p>row / column</p><ul><li><p>不考虑空位，保证先后顺序</p><ul><li>链接：<a href="https://jsbin.com/wapejok/edit?css,output">https://jsbin.com/wapejok/edit?css,output</a></li></ul></li></ul></li><li><p>row dense / column dense</p><ul><li><p>尽量紧密排列</p><ul><li>链接：<a href="https://jsbin.com/xutokec/edit?css,output">https://jsbin.com/xutokec/edit?css,output</a></li></ul></li></ul></li></ul><h3 id="单元格内容的位置"><a href="#单元格内容的位置" class="headerlink" title="单元格内容的位置"></a>单元格内容的位置</h3><ul><li><code>align-items</code> 垂直方向</li><li><code>justify-items</code> 水平方向</li><li>合并写法: <code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><h3 id="项目整体在容器内的位置"><a href="#项目整体在容器内的位置" class="headerlink" title="项目整体在容器内的位置"></a>项目整体在容器内的位置</h3><ul><li><p><code>justify-content</code> 水平方向</p></li><li><p><code>align-content</code> 垂直方向</p></li><li><p><code>place-content</code>  前两个的合并写法</p><ul><li><code>place-content: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul></li></ul><hr><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="指定项目位置"><a href="#指定项目位置" class="headerlink" title="指定项目位置"></a>指定项目位置</h3><ul><li><p><code>grid-row / column-start / end</code></p><ul><li><p>写法</p><ul><li>网格线数字</li><li>网格线名字</li><li>span：num</li><li>重叠了用<code>z-index</code></li></ul></li><li><p>简写</p><ul><li><code>grid-row / column: &lt;start-line&gt; / &lt;end-line&gt;</code></li></ul></li></ul></li></ul><h3 id="指定项目区域名"><a href="#指定项目区域名" class="headerlink" title="指定项目区域名"></a>指定项目区域名</h3><ul><li><code>grid-area: 区域名</code></li></ul><h3 id="单元格内容的位置-优先"><a href="#单元格内容的位置-优先" class="headerlink" title="单元格内容的位置(优先)"></a>单元格内容的位置(优先)</h3><ul><li><code>align-self</code> 垂直方向</li><li><code>justify-self</code> 水平方向</li><li>合并写法: <code>place-self: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><p><img src="/../images/4.%20%20grid%EF%BC%88%E7%BD%91%E6%A0%BC%EF%BC%89%E5%B8%83%E5%B1%80.png" alt="思维导图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2020/09/30/3.git-chang-yong-ming-ling/"/>
      <url>/2020/09/30/3.git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h5 id="集中式和分布式版本控制系统的区别"><a href="#集中式和分布式版本控制系统的区别" class="headerlink" title="集中式和分布式版本控制系统的区别"></a>集中式和分布式版本控制系统的区别</h5><blockquote><p>分布式版本控制系统：每个开发者都有整个代码库的所有版本，在离线状态下开发者可以进行版本管理开发, 等网络恢复再push到仓库中。</p></blockquote><blockquote><p>集中式版本控制系统：每个开发者只有应用代码库的一个版本，在离线状态下开发者无法进行版本管理开发。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="Git 工作区、暂存区和版本库"></p><ol><li><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6></li></ol><p><code>git init</code>:初始化仓库<br><code>git status</code> : 查看状态：红色表示在工作区，绿色表示在暂存区，其他在版本区<br><code>git add 文件名</code>  :工作区添加到暂存区，”.”号表所有<br><code>git commit -m '注释'</code> : 暂存区到版本区<br><code>git clone URL</code> : 克隆仓库<br><code>git remote add 别名 URL</code>: 本地仓库关联远程仓库,别名一般用origin<br><code>git remote remove 别名</code>: 本地仓库移除关联</p><ol start="2"><li><h6 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h6></li></ol><p><code>git checkout 分支</code> : 切换分支<br><code>git checkout -b 分支</code> : 创建并切换<br><code>git branch 分支</code> : 创建分支但不切换<br><code>git branch</code>: 查看分支列表<br><code>git checkout -d 分支</code> : 删除分支<br><code>git push origin 分支</code> : 分支推送远程<br><code>git pull origin 分支</code> : 远程拉取到本地<br><code>git fetch origin master:tmp</code>: 新建一个tmp分支，将远程仓库的master分支上代码版本复制到tmp分支上，不会自动合并<br><code>git merge 分支</code> : 指定分支合并到当前分支</p><ol start="3"><li><h6 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h6><p><code>git log</code>: 提交日志<br><code>git reflog</code>: 每次提交的ID<br><code>git reset --hard HEAD^</code>: 版本回退到一个版本，”^“回退一个版本，”^^”回退两个版本<br><code>git reset --hard ID号</code>:回退到指定版本</p></li><li><h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p><code>git rm 文件名</code>: 删除指定文件<br><code>git rm -r 文件名</code>: 删除指定文件夹<br><code>git rm --cached 文件</code>: 从暂存区删除 </p></li><li><h6 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h6></li></ol><p><code>git diff</code> : 比较暂存区与工作区<br><code>git diff --cached</code> : 比较版本区与暂存区<br><code>git diff master</code> : 比较版本区与工作区<br><code>git diff branch1 branch2</code>:显示出两个分支之间所有有差异的文件的详细差异<br><code>git diff branch1 branch2 --stat</code>:显示出两个分支之间所有有差异的文件列表<br><code>git diff branch1 branch2 xxx</code>:显示指定文件的详细差异</p><ol><li><h6 id="基础Linux命令"><a href="#基础Linux命令" class="headerlink" title="基础Linux命令"></a>基础Linux命令</h6></li></ol><p><code>mkdir</code> :创建文件夹<br><code>vi</code> : 创建文件并进入<br><code>i</code> :编辑模式<br><code>ESC+:+wq</code> : 保存并退出<br><code>ESC+:+q!</code> : 不保存并退出<br><code>cd</code> : 进入文件夹<br><code>ls</code> : 当前文件夹文件列表<br><code>pwd</code> : 当前目录<br><code>cat</code> 文件 : 显示文件内容<br><code>clear</code> : 清屏</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>betterScroll踩坑记录</title>
      <link href="/2020/09/20/1betterscroll-cai-keng-ji-lu/"/>
      <url>/2020/09/20/1betterscroll-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用BetterScroll刚<code>npm run serve</code>时无法进行滑动，需要修改BetterScroll的源码，<br>   修改<code>BetterSC/shared-utils/src/dom.ts</code> 中的常量hasTouch为true,<br>   这样就可以在初始化时对参数进行设置,把一切掌握在自己手中</p><p>   使用方法如下:</p><pre><code> new BScroll时,在参数options中加入 mouseWheel: true,   //开启鼠标滚轮 disableMouse: false,   //启用鼠标拖动 disableTouch: false    //启用手指触摸</code></pre><p>   参考博客：<a href="https://www.cnblogs.com/mldonkey/p/11421577.html">https://www.cnblogs.com/mldonkey/p/11421577.html</a></p></li></ol><ol start="2"><li>使用BetterScroll后绑定scroll, click事件后无法触发，也无报错<br> BetterScroll默认拦截了click事件可在<code>new Bscroll()</code>的配置对象中传入<code> click: true</code></li><li>使用BetterScroll的<code>scroll</code>事件必须同时在<code>new Bscroll()</code>配置对象中指定<code>probeType</code> </li></ol><p><img src="/../images/1.1.jpg" alt="what"></p><p>(后面发现官网都有说明… 链接：<a href="https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F">https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F</a>)</p><p><img src="/../images/1.2.jpg" alt="what"></p><p>. 使用better-scroll时注意$nextTick的使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue动态路由引入和异步组件记录</title>
      <link href="/2020/09/20/2.vue-router-dong-tai-lu-you/"/>
      <url>/2020/09/20/2.vue-router-dong-tai-lu-you/</url>
      
        <content type="html"><![CDATA[<p>动态引入的路由组件在打包时路由组件会被单独打包(代码分割 code split),<br>默认不请求加载路由组件打包文件, 当请求需要路由组件时才请求加载,当引入需要的的组件时在<code>Network</code>会增加一个打包文件(一般为<code>/^\d+.js$/</code>格式)。</p><h4 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h4><ul><li><p>component是一个执行就会<code>import()</code>的函数</p><pre><code>myComponent =  () =&gt; import(path)</code></pre></li><li><p>将组件定义对象(component definition)传递给 <code>resolve</code> 回调函数</p><pre><code>Vue.component(component, (resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve({      template: YourTemplate    })  }, 100)})</code></pre></li><li><p>使用<code>require</code>引入，这个特殊的 require 语法将指示 webpack 自动将构建后的代码，拆分到不同的 bundle 中，然后通过 Ajax 请求加载。</p><pre><code>Vue.component(component, (resolve) =&gt; {  setTimeOut(() =&gt; {    require(path, resolve);  }, 100)})</code></pre></li><li><p>使用返回的<code>promise</code>resolve前<code>import</code></p><pre><code>- Vue.component(component, (resolve) =&gt; {    setTimeOut(() =&gt; {      import(path).then(resolve);    }, 100)  })- Vue.component(component, Promise.resolve(template对象))- Vue.component(component, Promise.resolveDelay(template对象, time))</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

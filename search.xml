<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>betterScroll踩坑记录</title>
      <link href="/2020/09/20/1betterscroll-cai-keng-ji-lu/"/>
      <url>/2020/09/20/1betterscroll-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用BetterScroll刚<code>npm run serve</code>时无法进行滑动，需要修改BetterScroll的源码，<br>   修改<code>BetterSC/shared-utils/src/dom.ts</code> 中的常量hasTouch为true,<br>   这样就可以在初始化时对参数进行设置,把一切掌握在自己手中</p><p>   使用方法如下:</p><pre><code> new BScroll时,在参数options中加入 mouseWheel: true,   //开启鼠标滚轮 disableMouse: false,   //启用鼠标拖动 disableTouch: false    //启用手指触摸</code></pre><p>   参考博客：<a href="https://www.cnblogs.com/mldonkey/p/11421577.html">https://www.cnblogs.com/mldonkey/p/11421577.html</a></p></li></ol><ol start="2"><li>使用BetterScroll后绑定scroll, click事件后无法触发，也无报错<br> BetterScroll默认拦截了click事件可在<code>new Bscroll()</code>的配置对象中传入<code> click: true</code></li><li>使用BetterScroll的<code>scroll</code>事件必须同时在<code>new Bscroll()</code>配置对象中指定<code>probeType</code> </li></ol><p><img src="./1.1.jpg" alt="what"></p><p>(后面发现官网都有说明… 链接：<a href="https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F">https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F</a>)</p><p><img src="./1.2.jpg" alt="what"></p><p>. 使用better-scroll时注意$nextTick的使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-router动态路由</title>
      <link href="/2020/09/20/vue-router-dong-tai-lu-you/"/>
      <url>/2020/09/20/vue-router-dong-tai-lu-you/</url>
      
        <content type="html"><![CDATA[<p>动态引入的路由组件在打包时路由组件会被单独打包(代码分割 code split),<br>默认不请求加载路由组件打包文件, 当请求需要路由组件时才请求加载,当引入需要的的组件时在<code>Network</code>会增加一个打包文件(一般为<code>/\d+.js/</code>格式)。</p><h4 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h4><ul><li><p>component是一个执行就会<code>import()</code>的函数</p><pre><code>myComponent =  () =&gt; import(path)</code></pre></li><li><p>将模板传入resolve函数</p><pre><code>Vue.component(components, (resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve({      template: YourTemplate    })  }, 100)})</code></pre></li><li><p>使用<code>require</code>引入</p><pre><code>Vue.component(components, (resolve) =&gt; {  setTimeOut(() =&gt; {    require(path, resolve);  }, 100)})</code></pre></li><li><p>使用<code>import</code>返回的<code>promise</code>resolve</p><pre><code>Vue.component(components, (resolve) =&gt; {  setTimeOut(() =&gt; {    import(path).then(resolve);  }, 100)})</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

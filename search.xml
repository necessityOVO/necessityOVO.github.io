<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx 学习笔记</title>
      <link href="/2021/01/23/9-nginx-xue-xi-bi-ji/"/>
      <url>/2021/01/23/9-nginx-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="Nginx-学习笔记"><a href="#Nginx-学习笔记" class="headerlink" title="Nginx 学习笔记"></a><strong>Nginx 学习笔记</strong></h4><p>总结<br>1 、 Nginx 简介<br>（ 1 ） 什么是Nginx 和可以做什么事情<br>（ 2 ） 正向代理<br>（ 3 ） 反向代理<br>（ 4 ） 动静分离</p><p>2 、 在Linux中安装nginx</p><p>3 、 Nginx的常用命令和配置文件</p><p>4 、 Nginx配置实例 1 反向代理</p><p>5 、 Nginx配置实例 2 负载均衡</p><p>6 、 Nginx配置实例 3 动静分离</p><p>7 、 Nginx的高可用集群<br>（ 1 ） nginx配置主从模式<br>（ 2 ） nginx配置双主模式</p><h1 id="Nginx-的简介"><a href="#Nginx-的简介" class="headerlink" title="Nginx 的简介"></a>Nginx 的简介</h1><h5 id="1-、什么是nginx"><a href="#1-、什么是nginx" class="headerlink" title="1 、什么是nginx"></a>1 、什么是nginx</h5><p>Nginx是高性能的HTTP和反向代理的服务器，处理高并发能力是十分强大的，能经受高负<br>载的考验,有报告表明能支持高达 50,000个并发连接数。</p><h5 id="2-、正向代理"><a href="#2-、正向代理" class="headerlink" title="2 、正向代理"></a>2 、正向代理</h5><p>（ 1 ）需要在客户端配置代理服务器进行指定网站访问，隐藏了客户端的IP地址</p><p><img src="/archives/2021/01/23/9-nginx-xue-xi-bi-ji/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109110252280.png" alt="image-20210109110252280"></p><h5 id="3-、反向代理"><a href="#3-、反向代理" class="headerlink" title="3 、反向代理"></a>3 、反向代理</h5><p>服务器配置代理服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><p><img src="/archives/2021/01/23/9-nginx-xue-xi-bi-ji/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109110233040.png" alt="image-20210109110233040"></p><h5 id="4-、负载均衡"><a href="#4-、负载均衡" class="headerlink" title="4 、负载均衡"></a>4 、负载均衡</h5><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p><p><img src="/archives/2021/01/23/9-nginx-xue-xi-bi-ji/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109111630765.png" alt="image-20210109111630765"></p><h5 id="5-、动静分离"><a href="#5-、动静分离" class="headerlink" title="5 、动静分离"></a>5 、动静分离</h5><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速<br>度。降低原来单个服务器的压力。</p><blockquote><p>不需要跟数据库交互获取的资源都是静态资源</p></blockquote><p><img src="/archives/2021/01/23/9-nginx-xue-xi-bi-ji/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109113424433.png" alt="image-20210109113424433"></p><h1 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h1><h5 id="1-、准备工作"><a href="#1-、准备工作" class="headerlink" title="1 、准备工作"></a>1 、准备工作</h5><p>（ 1 ）打开虚拟机，使用远程连接工具连接linux操作系统<br>（ 2 ）到nginx官网下载软件：<a href="http://nginx.org/">http://nginx.org/</a></p><h5 id="2-、开始进行nginx安装"><a href="#2-、开始进行nginx安装" class="headerlink" title="2 、开始进行nginx安装"></a>2 、开始进行nginx安装</h5><blockquote><p>本来可以用 apt-get 的一起装的，但是想熟悉一下wget</p></blockquote><p>（ 1 ）安装pcre依赖</p><ol><li><p>联网下载pcre压缩文件依赖</p><pre><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</code></pre></li><li><p>解压压缩文件</p><pre><code>tar –zxvf pcre-8.37.tar.gz</code></pre></li><li><p>执行<code>./configure</code></p></li><li><p>回到pcre目录下执行<code>make</code>，最后执行<code>make install</code></p></li><li><p>查看版本：</p><pre><code>pcre-config --version</code></pre></li></ol><p>（ 2 ）安装openssl 、zlib 、 gcc 依赖</p><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</code></pre><p>（ 3 ）安装nginx</p><ol><li>使用命令解压</li><li>./configure</li><li>make &amp;&amp; make install</li></ol><p>进入目录 /usr/local/nginx/sbin/nginx 启动服务</p><blockquote><p>在windows系统中访问linux中nginx，默认不能访问的，因为防火墙问题<br>（ 1 ）关闭防火墙<br>（ 2 ）开放访问的端口号， 80 端口</p></blockquote><p>查看开放的端口号</p><pre><code>firewall-cmd --list-all</code></pre><p>设置开放的端口号</p><pre><code>firewall-cmd --add-service=http – permanentfirewall-cmd --add-port=80/tcp --permanent</code></pre><p>重启防火墙</p><pre><code>firewall-cmd **–** reload</code></pre><h1 id="Nginx-的常用的命令"><a href="#Nginx-的常用的命令" class="headerlink" title="Nginx 的常用的命令"></a>Nginx 的常用的命令</h1><p>进入nginx目录中<br>cd /usr/local/nginx/sbin</p><p>1 、查看nginx版本号</p><pre><code>./nginx -v或者nginx -v</code></pre><p>2 、启动nginx</p><pre><code>./nginxservice nginx start</code></pre><p>3 、停止nginx</p><pre><code>./nginx -s stop</code></pre><p>4 、重新加载nginx</p><pre><code>./nginx -s reload</code></pre><h1 id="Nginx-的配置文件"><a href="#Nginx-的配置文件" class="headerlink" title="Nginx 的配置文件"></a>Nginx 的配置文件</h1><h5 id="1-、nginx配置文件位置"><a href="#1-、nginx配置文件位置" class="headerlink" title="1 、nginx配置文件位置"></a>1 、nginx配置文件位置</h5><pre><code>cd /usr/local/nginx/conf/nginx.conf使用apt-get安装时，配置文件在 /etc/nginx 中</code></pre><h5 id="2-、配置文件中的内容"><a href="#2-、配置文件中的内容" class="headerlink" title="2 、配置文件中的内容"></a>2 、配置文件中的内容</h5><p>（ 1 ）全局块：配置服务器整体运行的配置指令</p><p>​            比如<code>worker_processes 1</code>：处理并发数的配置</p><p>（ 2 ）events块：影响 Nginx 服务器与用户的网络连接</p><p>​            比如<code>worker_connections 1024</code>： 支持的最大连接数为 1024</p><p>（ 3 ）http块<br>还包含两部分：<br>http全局块<br>server块</p><h1 id="Nginx-配置实例-反向代理实例-1"><a href="#Nginx-配置实例-反向代理实例-1" class="headerlink" title="Nginx 配置实例-反向代理实例 1"></a>Nginx 配置实例-反向代理实例 1</h1><h5 id="1-、实现效果"><a href="#1-、实现效果" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>（ 1 ）打开浏览器，在浏览器地址栏输入地址 <strong><em><a href="http://www.123.com/">http://www.123.com</a></em></strong> ，跳转到liunx系统tomcat主页面中</p><h5 id="2-、准备工作"><a href="#2-、准备工作" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）在liunx系统安装tomcat，使用默认端口 8080</p><ul><li>tomcat安装文件放到liunx系统中，解压</li><li>进入tomcat的bin目录中，./startup.sh启动tomcat服务器</li></ul><h3 id="（-2-）对外开放访问的端口"><a href="#（-2-）对外开放访问的端口" class="headerlink" title="（ 2 ）对外开放访问的端口"></a>（ 2 ）对外开放访问的端口</h3><pre><code>firewall-cmd --add-port=80 80 /tcp --permanentfirewall-cmd **–** reload</code></pre><h3 id="查看已经开放的端口号"><a href="#查看已经开放的端口号" class="headerlink" title="查看已经开放的端口号"></a>查看已经开放的端口号</h3><pre><code>firewall-cmd --list-all</code></pre><p>（ 3 ）在windows系统中通过浏览器访问tomcat服务器</p><h5 id="3-、访问过程的分析"><a href="#3-、访问过程的分析" class="headerlink" title="3 、访问过程的分析"></a>3 、访问过程的分析</h5><p><img src="/archives/2021/01/23/9-nginx-xue-xi-bi-ji/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115049027.png" alt="image-20210109115049027"></p><h5 id="4-、具体配置"><a href="#4-、具体配置" class="headerlink" title="4 、具体配置"></a>4 、具体配置</h5><p>第一步 在windows系统的host文件进行域名和ip对应关系的配置</p><p>（ 1 ）添加内容在host文件中</p><p>第二步 在nginx进行请求转发的配置（反向代理配置）</p><h5 id="5-、最终测试"><a href="#5-、最终测试" class="headerlink" title="5 、最终测试"></a>5 、最终测试</h5><h1 id="Nginx-配置实例-反向代理实例-2"><a href="#Nginx-配置实例-反向代理实例-2" class="headerlink" title="Nginx 配置实例-反向代理实例 2"></a>Nginx 配置实例-反向代理实例 2</h1><h5 id="1-、实现效果-1"><a href="#1-、实现效果-1" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>使用nginx反向代理，根据访问的路径跳转到不同端口的服务中<br>nginx监听端口为 9001 ，</p><p>访问 <a href="http://192.168.17.129:9001/edu/">http://192.168.17.129:9001/edu/</a> 直接跳转到127.0.0.1:808 0<br>访问 <a href="http://">http://</a> 192.168.17.129:9001/vod/ 直接跳转到127.0.0.1:808 1</p><h5 id="2-、准备工作-1"><a href="#2-、准备工作-1" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）准备两个tomcat服务器，一个 8080 端口，一个 8081 端口<br>（ 2 ）创建文件夹和测试页面</p><h5 id="3-、具体配置"><a href="#3-、具体配置" class="headerlink" title="3 、具体配置"></a>3 、具体配置</h5><p>（ 1 ）找到nginx配置文件，进行反向代理配置</p><p>（ 2 ）开放对外访问的端口号 9001 8080 8081</p><h5 id="4-、最终测试"><a href="#4-、最终测试" class="headerlink" title="4 、最终测试"></a>4 、最终测试</h5><h1 id="Nginx-配置实例-负载均衡"><a href="#Nginx-配置实例-负载均衡" class="headerlink" title="Nginx 配置实例-负载均衡"></a>Nginx 配置实例-负载均衡</h1><h5 id="1-、实现效果-2"><a href="#1-、实现效果-2" class="headerlink" title="1 、实现效果"></a>1 、实现效果</h5><p>（ 1 ）浏览器地址栏输入地址 <a href="http://192.168.17.129/edu/a.html%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%8C%E5%B9%B3%E5%9D%87">http://192.168.17.129/edu/a.html，负载均衡效果，平均</a> 8080<br>和 8081 端口中</p><h5 id="2-、准备工作-2"><a href="#2-、准备工作-2" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）准备两台tomcat服务器，一台 8080 ，一台 8081<br>（ 2 ）在两台tomcat里面webapps目录中，创建名称是edu文件夹，在edu文件夹中创建<br>页面a.html，用于测试</p><h5 id="3-、在nginx的配置文件中进行负载均衡的配置"><a href="#3-、在nginx的配置文件中进行负载均衡的配置" class="headerlink" title="3 、在nginx的配置文件中进行负载均衡的配置"></a>3 、在nginx的配置文件中进行负载均衡的配置</h5><h5 id="4-、nginx分配服务器策略"><a href="#4-、nginx分配服务器策略" class="headerlink" title="4 、nginx分配服务器策略"></a>4 、nginx分配服务器策略</h5><p>第一种 轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>第二种weight<br>weight代表权重默认为1,权重越高被分配的客户端越多</p><p>第三种ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器</p><p>第四种fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><h1 id="Nginx-配置实例-动静分离"><a href="#Nginx-配置实例-动静分离" class="headerlink" title="Nginx 配置实例-动静分离"></a>Nginx 配置实例-动静分离</h1><h5 id="1-、什么是动静分离"><a href="#1-、什么是动静分离" class="headerlink" title="1 、什么是动静分离"></a>1 、什么是动静分离</h5><p><img src="/archives/2021/01/23/9-nginx-xue-xi-bi-ji/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115255261.png" alt="image-20210109115255261"></p><p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏<br>览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源<br>设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，<br>所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，<br>不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一<br>个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304 ，<br>如果有修改，则直接从服务器重新下载，返回状态码 200 。</p><h5 id="2-、准备工作-3"><a href="#2-、准备工作-3" class="headerlink" title="2 、准备工作"></a>2 、准备工作</h5><p>（ 1 ）在liunx系统中准备静态资源，用于进行访问</p><h5 id="3-、具体配置-1"><a href="#3-、具体配置-1" class="headerlink" title="3 、具体配置"></a>3 、具体配置</h5><p>（ 1 ）在nginx配置文件中进行配置</p><h5 id="4-、最终测试-1"><a href="#4-、最终测试-1" class="headerlink" title="4 、最终测试"></a>4 、最终测试</h5><p>（ 1 ）浏览器中输入地址：<a href="http://192.168.17.129/image/01.jpg">http://192.168.17.129/image/01.jpg</a></p><ul><li>因为配置文件 autoindex on</li></ul><p>（ 2 ）在浏览器地址栏输入地址：<a href="http://192.168.17.129/www/a.html">http://192.168.17.129/www/a.html</a></p><h1 id="Nginx-配置高可用的集群"><a href="#Nginx-配置高可用的集群" class="headerlink" title="Nginx 配置高可用的集群"></a>Nginx 配置高可用的集群</h1><h5 id="1-、什么是nginx高可用"><a href="#1-、什么是nginx高可用" class="headerlink" title="1 、什么是nginx高可用"></a>1 、什么是nginx高可用</h5><p><img src="/archives/2021/01/23/9-nginx-xue-xi-bi-ji/Users\10615\AppData\Roaming\Typora\typora-user-images\image-20210109115401695.png" alt="image-20210109115401695"></p><p>（ 1 ）需要两台nginx服务器<br>（ 2 ）需要keepalived<br>（ 3 ）需要虚拟ip</p><h5 id="2-、配置高可用的准备工作"><a href="#2-、配置高可用的准备工作" class="headerlink" title="2 、配置高可用的准备工作"></a>2 、配置高可用的准备工作</h5><h3 id="（-1-）需要两台服务器-192-168-17-129-和-192-168-17"><a href="#（-1-）需要两台服务器-192-168-17-129-和-192-168-17" class="headerlink" title="（ 1 ）需要两台服务器 192.168.17.129 和 192.168.17."></a>（ 1 ）需要两台服务器 192.168.17.129 和 192.168.17.</h3><p>（ 2 ）在两台服务器安装nginx<br>（ 3 ）在两台服务器安装keepalived</p><h5 id="3-、在两台服务器安装keepalived"><a href="#3-、在两台服务器安装keepalived" class="headerlink" title="3 、在两台服务器安装keepalived"></a>3 、在两台服务器安装keepalived</h5><p>（ 1 ）使用yum命令进行安装<br>yum install keepalived <strong>–</strong> y</p><p>（ 2 ）安装之后，在etc里面生成目录keepalived，有文件keepalived.conf</p><h5 id="4-、完成高可用配置（主从配置）"><a href="#4-、完成高可用配置（主从配置）" class="headerlink" title="4 、完成高可用配置（主从配置）"></a>4 、完成高可用配置（主从配置）</h5><p>（ 1 ）修改/etc/keepalived/keepalivec.conf配置文件</p><pre><code>global_defs {notification_email {acassen@firewall.locfailover@firewall.locsysadmin@firewall.loc}notification_email_from Alexandre.Cassen@firewall.locsmtp_server 192.168.17.smtp_connect_timeout 30router_id LVS_DEVEL}vrrp_script chk_http_port {script "/usr/local/src/nginx_check.sh"interval 2 #（检测脚本执行的间隔）weight 2}vrrp_instance VI_1 {state BACKUP # 备份服务器上将 MASTER 改为 BACKUPinterface ens33 //网卡virtual_router_id 51 # 主、备机的virtual_router_id必须相同priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小advert_int 1authentication {auth_type PASSauth_pass 1111}virtual_ipaddress {192.168.17.50 // VRRP H虚拟地址}}</code></pre><p>（ 2 ）在/usr/local/src添加检测脚本</p><pre><code>#!/bin/bashA=`ps -C nginx –no-header |wc -l`if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived fifi</code></pre><p>（ 3 ）把两台服务器上nginx和keepalived启动<br>启动nginx：./nginx<br>启动keepalived：systemctl start keepalived.service</p><h5 id="5-、最终测试-1"><a href="#5-、最终测试-1" class="headerlink" title="5 、最终测试"></a>5 、最终测试</h5><p>（ 1 ）在浏览器地址栏输入 虚拟ip地址 192.168.17.</p><p>（ 2 ）把主服务器（192.168.17.129）nginx和keepalived停止，再输入192.168.17.</p><h2 id="Nginx的原理"><a href="#Nginx的原理" class="headerlink" title="Nginx的原理"></a>Nginx的原理</h2><p>1 、mater和worker</p><p>2 、worker如何进行工作的</p><p>3 、一个master和多个woker有好处<br>（ 1 ）可以使用nginx <strong>–</strong> s reload 热部署，利用nginx进行热部署操作<br>（ 2 ）每个woker是独立的进程，如果有其中的一个woker出现问题，其他woker独立的，<br>继续进行争抢，实现请求过程，不会造成服务中断</p><p>4 、设置多少个woker合适</p><p>worker数和服务器的cpu数相等是最为适宜的</p><p>5 、连接数worker_connection<br>第一个：发送请求，占用了woker的几个连接数？<br>答案： 2 或者 4 个</p><p>第二个：nginx有一个master，有四个woker，每个woker支持最大的连接数 1024 ，支持的<br>最大并发数是多少？</p><ul><li>普通的静态访问最大并发数是： worker_connections * worker_processes /2</li><li>而如果是HTTP作 为反向代理来说，最大并发数量应该是worker_connections *<br>worker_processes/4。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器、nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jest笔记</title>
      <link href="/2021/01/20/8-jest-xue-xi-bi-ji/"/>
      <url>/2021/01/20/8-jest-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="1、jest介绍"><a href="#1、jest介绍" class="headerlink" title="1、jest介绍"></a>1、jest介绍</h1><p>主流前端测试框架：Jasmine，MOCHA，jest</p><h4 id="jest优点："><a href="#jest优点：" class="headerlink" title="jest优点："></a>jest优点：</h4><ul><li>新技术</li><li>性能好、功能多、简单易用</li><li>能差异化测试，只测试变化的模块</li><li>快出覆盖率</li><li>多项目并行</li></ul><h4 id="单元测试和集成测试的区别"><a href="#单元测试和集成测试的区别" class="headerlink" title="单元测试和集成测试的区别"></a>单元测试和集成测试的区别</h4><ul><li><strong>单元测试unit testing</strong>：指对软件中的最小可测试单元进行检查和验证。<strong>前端所说的单元测试就是对一个模块进行测试</strong></li><li><strong>集成测试</strong>：也叫组装测试或者联合测试。在单元测试的基础上，将所有模块按照涉及要求组装成为子系统或系统，进行集成测试。</li></ul><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><ol><li><code>npm i jest</code></li><li>修改package.json 的<code>script</code>的<code>test</code>为<code>jest</code>, 或者<code>jest --watchAll</code>(自动监测变化并测试，但有时测试结果是错误的:&lt;)</li><li><code>npm test</code></li></ol><h1 id="2、jest配置"><a href="#2、jest配置" class="headerlink" title="2、jest配置"></a>2、jest配置</h1><blockquote><p>只对<code>&lt;name&gt;.test.js</code>的文件进行测试</p></blockquote><h4 id="生成配置文件jest-config-js："><a href="#生成配置文件jest-config-js：" class="headerlink" title="生成配置文件jest.config.js："></a>生成配置文件jest.config.js：</h4><pre><code>npx jest --init</code></pre><h4 id="生成覆盖率报告："><a href="#生成覆盖率报告：" class="headerlink" title="生成覆盖率报告："></a>生成覆盖率报告：</h4><pre><code>npx jest --coverage</code></pre><blockquote><p>覆盖率报告文件夹的名字可通过 jest.config.js的<code>coverageDirectroy</code>指定</p></blockquote><h4 id="使jest支持es6的import语法：利用babel将es6转为commonjs语法"><a href="#使jest支持es6的import语法：利用babel将es6转为commonjs语法" class="headerlink" title="使jest支持es6的import语法：利用babel将es6转为commonjs语法"></a>使jest支持es6的import语法：利用babel将es6转为commonjs语法</h4><p>​    配置：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"presets"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>      <span class="token property">"targets"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"node"</span><span class="token operator">:</span> <span class="token string">"current"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h1 id="3、匹配器"><a href="#3、匹配器" class="headerlink" title="3、匹配器"></a>3、匹配器</h1><p>官网匹配器地址：<a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a></p><ol><li><p>toBe(): 相当于 <code>===</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toBe'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 就是 ===</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toEqual()： 外形是否一样</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toEqual'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 外形</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toBeNull()：是null</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeNull', () => {  let a = null  expect(a).toBeNull()})</code></pre></li><li><p>toBeUndefined / toBeDefined：是否定义</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeUndefined', () => {  let a   expect(a).toBeUndefined()})</code></pre></li><li><p>toBeTruthy / toBeFalsy：转换为布尔值后为true还是false</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'toBeTruthy'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">expect</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBeTruthy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>toBeGreaterThan / toBeLessThan / toBeGreaterThanOrEqual / toBeLessThanOrEqual：数值比较</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeGreaterThan', () => {   // 大于  let a = 10  expect(a).toBeGreaterThan(4)})</code></pre></li><li><p>toBeCloseTo ：解决浮点数计算不精确的问题</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toBeCloseTo', () => {       // 解决浮点数计算不精确的问题  expect(0.1 + 0.2).toBeCloseTo(0.3)})</code></pre></li><li><p>toMatch：字符串内是否包含</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toMatch', () => {         // 字符串内是否包含  const arr = 'li, liu, wang'  expect(arr).toMatch('wang')})</code></pre></li><li><p>toContain：数组、set内是否包含</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toContain', () => {       // 数组、set内是否包含  const arr=['谢大脚','刘英','小红']  const data = new Set(arr)  expect(data).toContain('谢大脚')})</code></pre></li><li><p>toThrow：程序内是否抛出异常</p><pre class=" language-JavaScript"><code class="language-JavaScript">test('toThrow', () => {       // 程序内是否抛出异常  function throwError() {    // throw new Error('this is an error')  }  expect(throwError).not.toThrow('this is an error')    //使用 .not取反  // expect(outError).toThrow('this is an error')})</code></pre></li></ol><h1 id="4、异步代码测试"><a href="#4、异步代码测试" class="headerlink" title="4、异步代码测试"></a>4、异步代码测试</h1><blockquote><p>未明白原理，需要补充！！！！！！</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'异步代码测试'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用`done`表征异步完成</span>  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">expect</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>使用async/await实现：</p><pre><code></code></pre><h1 id="5、钩子函数"><a href="#5、钩子函数" class="headerlink" title="5、钩子函数"></a>5、钩子函数</h1><blockquote><p>钩子函数只作用于当前的文件</p></blockquote><ul><li><p>beforeAll(callback)：在所有测试用例之前进行执行</p></li><li><p>afterAll(callback)：完成所有测试用例之后才执行的函数</p></li><li><p>beforeEach(callback)：每个测试用例前都会执行一次的钩子函数</p></li><li><p>afterEach(callback)：每次测试用例完成测试之后执行一次的钩子函数</p><pre class=" language-JavaScript"><code class="language-JavaScript">// 举例afterEach(()=>{        console.log('afterEach')})</code></pre></li></ul><h1 id="6、测试作用域"><a href="#6、测试作用域" class="headerlink" title="6、测试作用域"></a>6、测试作用域</h1><p><code>describe(测试用例)</code>：创建作用域</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 测试、jest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;7.babel学习笔记&#39;</title>
      <link href="/2021/01/08/7-babel-xue-xi-bi-ji/"/>
      <url>/2021/01/08/7-babel-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>学习地址：<a href="https://www.jiangruitao.com/babel/">姜瑞涛的官方网站</a></p><blockquote><p>babel是一个工具集，主要用于将ES6的js代码转为ES5等向后兼容的js代码</p></blockquote><h2 id="一、必要部分："><a href="#一、必要部分：" class="headerlink" title="一、必要部分："></a>一、必要部分：</h2><ol><li>babel配置文件：babelrc、babel.js、babel.config.js或package.json</li><li>相关的npm依赖</li><li>需要转码的js文件</li></ol><h2 id="二、作用："><a href="#二、作用：" class="headerlink" title="二、作用："></a>二、作用：</h2><ol><li>语法转换</li><li>补齐api     =&gt; polyfill (babel默认只转换JavaScript语法，不转换api)</li></ol><h2 id="三、版本"><a href="#三、版本" class="headerlink" title="三、版本"></a>三、版本</h2><blockquote><p>Babel是一个工具集，而这个工具集是围绕@babel/core这个核心npm包构成的。每次@babel/core发布新版本的时候，整个工具集的其它npm包也都会跟着升级到与@babel/core相同的版本号，即使它们的代码可能一行都没有改变</p></blockquote><ul><li><p>v7：<code>@babel/core</code></p></li><li><p>v6：<code>babel-core</code></p></li></ul><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><blockquote><p>建议使用babel.config.js文件，可以进行逻辑处理</p></blockquote><ol><li><p>预设数组<code>presets</code>：就是一组Babel插件的集合</p><ol><li><strong>@babel/preset-env</strong>：TC39每年发布的进入标准的ES语法的转换器预设集合</li><li>@babel/preset-flow</li><li>@babel/preset-react</li><li>@babel/preset-typescript</li></ol></li><li><p>插件数组<code>plugins</code>：@babel/plugin-transform-runtime常用</p></li><li><p>其他<code>minified</code>、<code>ignore</code>等</p><blockquote><p><strong>plugin与preset的短名称：</strong></p><p>​    如果插件的npm包名称的前缀为 babel-plugin-，可以省略前缀。</p><p>​    如果npm包名称的前缀带有npm作用域@，例如@org/babel-plugin-xxx,短名称可以写成@org/xxx，但babel官方并没有给出明确的说明，所以还是推荐用全称。</p></blockquote></li></ol><p><strong>执行顺序：</strong></p><ul><li>插件比预设先执行</li><li>插件执行顺序是插件数组从前向后执行</li><li>预设执行顺序是预设数组从后向前执行</li></ul><h2 id="五、常用包及配置："><a href="#五、常用包及配置：" class="headerlink" title="五、常用包及配置："></a>五、常用包及配置：</h2><blockquote><p>默认为 v7</p></blockquote><ol><li>@babel/cli：Babel命令行转码工具，如果我们<strong>使用命令行</strong>进行Babel转码就需要安装它。</li></ol><ol start="2"><li>@babel/core：Babel的核心npm包。</li></ol><ol start="3"><li><p><strong>@babel/preset-env</strong>(常用)：提供了ES6转换ES5的语法转换规则</p><p>配置：</p><pre class=" language-json"><code class="language-json">presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"@babel/env"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    targets<span class="token operator">:</span> <span class="token punctuation">{</span>        //转码的最低环境        <span class="token property">"chrome"</span><span class="token operator">:</span> <span class="token string">"58"</span><span class="token punctuation">,</span>        <span class="token property">"ie"</span><span class="token operator">:</span> <span class="token string">"11"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    useBuiltIns<span class="token operator">:</span> <span class="token string">"usage"</span><span class="token punctuation">,</span>    //见下    corejs<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>    //取值为<span class="token number">2</span>或<span class="token number">3</span>，指定core-js的使用版本    modules<span class="token operator">:</span><span class="token string">"false"</span><span class="token punctuation">,</span>     //见下<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></code></pre><ul><li><p><code>useBuiltIns</code>：</p><p>取值：    </p><ul><li><code>usage</code>：自动引入需要用到的polyfill</li><li><code>entry</code>：需要自行引入polyfill，且不会根据我们实际用到的API进行针对性引入polyfill</li><li><code>false</code></li></ul><blockquote><p>使用<code>entry</code>这种方式的时候，只能<code>import polyfill</code>一次，一般都是在入口文件。如果进行多次import，会发生错误。</p></blockquote></li><li><p><code>modules</code>：取值可以是<code>amd</code>、<code>umd</code> 、 <code>systemjs</code> 、 <code>commonjs</code> 、<code>cjs</code> 、<code>auto</code> 、<code>false</code>使用的模块语法</p><blockquote><p>在该参数项值是<code>auto</code>或不设置的时候，会发现我们转码前的代码里import都被转码成require了。</p><p>如果我们将参数项改成<code>false</code>，那么就不会对ES6模块化进行更改，还是使用import引入模块。</p></blockquote></li></ul></li></ol><ol start="4"><li><p><strong>@babel/polyfill</strong>： 垫片，从babel7.4开始，官方不推荐再使用了，因为@babel/polyfill本身其实就是两个npm包的集合：<strong>core-js与regenerator-runtime</strong>。</p><p>官方推荐直接使用这两个npm包。虽然@babel/polyfill还在进行版本升级，但其使用的core-js包为2.x.x版本，而core-js这个包本身已经发布到了3.x.x版本了，@babel/polyfill以后也不会使用3.x.x版本的包了。新版本的core-js实现了许多新的功能，例如数组的includes方法。</p><p>​        <strong>转码环境判断</strong>：如果我们的@babel/preset-env不设置任何参数，Babel就会完全根据package.json的<code>browserslist</code>的配置来做语法转换。如果没有browserslist，那么Babel就会把所有ES6的语法转换成ES5版本。</p><blockquote><p>注意：Babel使用browserslist的配置功能依赖于@babel/preset-env，如果Babel没有配置任何预设或插件，那么Babel对转换的代码会不做任何处理</p></blockquote></li></ol><ol start="5"><li><p><strong>@babel/runtime、<del>runtime-corejs2、</del>runtime-corejs3</strong>：原始的preset-env会在所有文件中重复注入辅助函数实现语法转换，将所有辅助函数移入runtime文件中再import入对应文件就不会增大项目体积了</p><p><a href="https://www.jiangruitao.com/babel/transform-runtime/">示例查看</a></p></li></ol><ol start="6"><li><p><strong>@babel/plugin-transform-runtime</strong>: @babel-runtime不能实现自动引入对应的辅助函数，借助此插件实现</p><pre class=" language-json"><code class="language-json">// 配置的默认值<span class="token punctuation">{</span>     <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>        <span class="token string">"@babel/plugin-transform-runtime"</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token property">"helpers"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    // 是否引入辅助包            <span class="token property">"corejs"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    //为<span class="token boolean">false</span>、<span class="token number">2</span>、<span class="token number">3</span>，一般开发JS库的时候才设置为<span class="token number">2</span>或<span class="token number">3</span>              <span class="token property">"regenerator"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    //转换async，await              <span class="token property">"useESModules"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>//是否使用es6的模块语法              <span class="token property">"absoluteRuntime"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    //用来自定义@babel/plugin-transform-runtime引入@babel/runtime/模块的路径规则              <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"7.0.0-beta.0"</span>    //该项主要是和@babel/runtime及其进化版@babel/runtime-corejs2、@babel/runtime-corejs3的版本号有关，这三个包我们只需要根据需要安装一个。我们把安装的npm包的版本号设置给version即可。例如，在上节的babel14例子里，安装的@babel/runtime-corejs3版本是^<span class="token number">7.10</span>.<span class="token number">4</span>，那么配置项version也取’^<span class="token number">7.10</span>.<span class="token number">4</span>’。//其实该项不填取默认值就行，目前填写版本号主要是可以减少打包体积。            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>​    作用：</p><ul><li>自动移除语法转换后内联的辅助函数，通过引入@babel/runtime/helpers里的辅助函数来替代；</li><li>当代码里使用了core-js的API，自动引入@babel/runtime-corejs3/core-js-stable/，以此来替代全局引入的core-js/stable</li><li>当代码里使用了Generator/async函数，自动引入@babel/runtime/regenerator以此来替代全局引入的regenerator-runtime/runtime；</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在create-react-app创建的项目中对antd的样式按需引入</title>
      <link href="/2020/10/25/6-zai-create-react-app-chuang-jian-de-xiang-mu-zhong-dui-antd-de-yang-shi-an-xu-yin-ru/"/>
      <url>/2020/10/25/6-zai-create-react-app-chuang-jian-de-xiang-mu-zhong-dui-antd-de-yang-shi-an-xu-yin-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="在create-react-app创建的项目中对antd的样式按需引入"><a href="#在create-react-app创建的项目中对antd的样式按需引入" class="headerlink" title="在create-react-app创建的项目中对antd的样式按需引入"></a>在create-react-app创建的项目中对antd的样式按需引入</h1><ol><li><p>下载 customize-cra,  react-app-rewired,  babel-plugin-import</p><blockquote><p><code>yarn add customize-cra react-app-rewired babel-plugin-import --dev</code></p></blockquote><p>​            customize-cra文档：<a href="https://github.com/arackaf/customize-cra">https://github.com/arackaf/customize-cra</a></p><p>​            react-app-rewired文档：<a href="https://github.com/timarney/react-app-rewired">https://github.com/timarney/react-app-rewired</a></p><p>​            babel-plugin-import文档：<a href="https://github.com/ant-design/babel-plugin-import">https://github.com/ant-design/babel-plugin-import</a></p></li></ol><ol start="2"><li><p>在package.json的同级创建config-overrides.js文件</p></li><li><p>config-overrides.js文件配置</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span> override<span class="token punctuation">,</span> fixBabelImports <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'customize-cra'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">override</span><span class="token punctuation">(</span>    <span class="token function">fixBabelImports</span><span class="token punctuation">(</span><span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>           libraryName<span class="token punctuation">:</span> <span class="token string">'antd'</span><span class="token punctuation">,</span>        libraryDirectory<span class="token punctuation">:</span> <span class="token string">'lib'</span><span class="token punctuation">,</span>        style<span class="token punctuation">:</span> <span class="token string">"css"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//如果是less文件则改为true</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fixBabelImports配置：<a href="https://github.com/arackaf/customize-cra/blob/master/api.md#fixbabelimportslibraryname-options">https://github.com/arackaf/customize-cra/blob/master/api.md#fixbabelimportslibraryname-options</a></p></li></ol><p>   import部分配置找babel-plugin-import：<a href="https://github.com/ant-design/babel-plugin-import#usage">https://github.com/ant-design/babel-plugin-import#usage</a></p><ol start="4"><li><p>修改package.json的<code>script</code>选项</p><p>​    安装react-app-rewired后的：<a href="https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts-for-start-build-and-test">https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts-for-start-build-and-test</a></p><pre><code>  /* package.json */  "scripts": {-   "start": "react-scripts start",+   "start": "react-app-rewired start",-   "build": "react-scripts build",+   "build": "react-app-rewired build",-   "test": "react-scripts test",+   "test": "react-app-rewired test",    "eject": "react-scripts eject"}</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>grid（网格）布局</title>
      <link href="/2020/09/30/4-grid-wang-ge-bu-ju/"/>
      <url>/2020/09/30/4-grid-wang-ge-bu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="grid（网格）布局"><a href="#grid（网格）布局" class="headerlink" title="grid（网格）布局"></a>grid（网格）布局</h1><h6 id="参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html"><a href="#参考链接-http-www-ruanyifeng-com-blog-2019-03-grid-layout-tutorial-html" class="headerlink" title="参考链接 http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html"></a>参考链接 <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></h6><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a><code>display</code></h3><p>采用网格(grid)布局<br>==注意==: 设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><ul><li><code>grid</code>：块级容器</li><li><code>inline-grid</code>：行内容器</li></ul><h3 id="grid-auto-columns-rows"><a href="#grid-auto-columns-rows" class="headerlink" title="grid-auto-columns / rows"></a><code>grid-auto-columns / rows</code></h3><ul><li>设置自动创建的多余网格的列宽和行高</li></ul><h3 id="grid-template-rows-columns"><a href="#grid-template-rows-columns" class="headerlink" title="grid-template-rows / columns"></a><code>grid-template-rows / columns</code></h3><ul><li><p>指定行列宽度</p><ul><li><p>用像素或百分比</p><pre><code>grid-template-rows: 100px 100px 100px;grid-template-columns: 33.3% 33.3% 33.3%;</code></pre></li><li><p>repeat()</p><pre><code>  grid-template-rows: repeat（3,100px）</code></pre></li><li><p>auto-fill</p><pre><code>grid-template-columns: repeat(auto-fill, 100px);</code></pre></li><li><p>fr单位(既fraction)</p><pre><code>grid-template-columns: 1fr 1fr;</code></pre></li><li><p>minmax(min, max)</p></li></ul></li><li><p>网格线名称</p><p>注意三行应制定四行网格线</p><ul><li>[name]</li></ul></li></ul><h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a><code>grid-template-areas</code></h3><ul><li>定义区域，名字即为网格网格名</li></ul><pre><code>    grid-template-areas: 'a b c'                               'd e f'                               'g h i';</code></pre><p>  不要利用的区域用”点”(.)表示<br>  注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h3 id="grid-row-column-gap"><a href="#grid-row-column-gap" class="headerlink" title="grid-row / column-gap"></a><code>grid-row / column-gap</code></h3><p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><ul><li><p>指定行列的间距</p></li><li><p>合并写法</p><ul><li><code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</code></li><li><code>gap: &lt;row-gap&gt; &lt;column-gap&gt;;</code></li></ul></li></ul><h3 id="grid-auto-flow-先行后列"><a href="#grid-auto-flow-先行后列" class="headerlink" title="grid-auto-flow  先行后列"></a><code>grid-auto-flow</code>  先行后列</h3><ul><li><p>row / column</p><ul><li><p>不考虑空位，保证先后顺序</p><ul><li>链接：<a href="https://jsbin.com/wapejok/edit?css,output">https://jsbin.com/wapejok/edit?css,output</a></li></ul></li></ul></li><li><p>row dense / column dense</p><ul><li><p>尽量紧密排列</p><ul><li>链接：<a href="https://jsbin.com/xutokec/edit?css,output">https://jsbin.com/xutokec/edit?css,output</a></li></ul></li></ul></li></ul><h3 id="单元格内容的位置"><a href="#单元格内容的位置" class="headerlink" title="单元格内容的位置"></a>单元格内容的位置</h3><ul><li><code>align-items</code> 垂直方向</li><li><code>justify-items</code> 水平方向</li><li>合并写法: <code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><h3 id="项目整体在容器内的位置"><a href="#项目整体在容器内的位置" class="headerlink" title="项目整体在容器内的位置"></a>项目整体在容器内的位置</h3><ul><li><p><code>justify-content</code> 水平方向</p></li><li><p><code>align-content</code> 垂直方向</p></li><li><p><code>place-content</code>  前两个的合并写法</p><ul><li><code>place-content: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul></li></ul><hr><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="指定项目位置"><a href="#指定项目位置" class="headerlink" title="指定项目位置"></a>指定项目位置</h3><ul><li><p><code>grid-row / column-start / end</code></p><ul><li><p>写法</p><ul><li>网格线数字</li><li>网格线名字</li><li>span：num</li><li>重叠了用<code>z-index</code></li></ul></li><li><p>简写</p><ul><li><code>grid-row / column: &lt;start-line&gt; / &lt;end-line&gt;</code></li></ul></li></ul></li></ul><h3 id="指定项目区域名"><a href="#指定项目区域名" class="headerlink" title="指定项目区域名"></a>指定项目区域名</h3><ul><li><code>grid-area: 区域名</code></li></ul><h3 id="单元格内容的位置-优先"><a href="#单元格内容的位置-优先" class="headerlink" title="单元格内容的位置(优先)"></a>单元格内容的位置(优先)</h3><ul><li><code>align-self</code> 垂直方向</li><li><code>justify-self</code> 水平方向</li><li>合并写法: <code>place-self: &lt;align-items&gt; &lt;justify-items&gt;;</code></li></ul><p><img src="/../images/4.%20%20grid%EF%BC%88%E7%BD%91%E6%A0%BC%EF%BC%89%E5%B8%83%E5%B1%80.png" alt="思维导图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2020/09/30/3-git-chang-yong-ming-ling/"/>
      <url>/2020/09/30/3-git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h5 id="集中式和分布式版本控制系统的区别"><a href="#集中式和分布式版本控制系统的区别" class="headerlink" title="集中式和分布式版本控制系统的区别"></a>集中式和分布式版本控制系统的区别</h5><blockquote><p>分布式版本控制系统：每个开发者都有整个代码库的所有版本，在离线状态下开发者可以进行版本管理开发, 等网络恢复再push到仓库中。</p></blockquote><blockquote><p>集中式版本控制系统：每个开发者只有应用代码库的一个版本，在离线状态下开发者无法进行版本管理开发。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="Git 工作区、暂存区和版本库"></p><ol><li><h6 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h6></li></ol><p><code>git init</code>:初始化仓库<br><code>git status</code> : 查看状态：红色表示在工作区，绿色表示在暂存区，其他在版本区<br><code>git add 文件名</code>  :工作区添加到暂存区，”.”号表所有<br><code>git commit -m '注释'</code> : 暂存区到版本区<br><code>git clone URL</code> : 克隆仓库<br><code>git remote add 别名 URL</code>: 本地仓库关联远程仓库,别名一般用origin<br><code>git remote remove 别名</code>: 本地仓库移除关联</p><ol start="2"><li><h6 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h6></li></ol><p><code>git checkout 分支</code> : 切换分支<br><code>git checkout -b 分支</code> : 创建并切换<br><code>git branch 分支</code> : 创建分支但不切换<br><code>git branch</code>: 查看分支列表<br><code>git checkout -d 分支</code> : 删除分支<br><code>git push origin 分支</code> : 分支推送远程<br><code>git pull origin 分支</code> : 远程拉取到本地<br><code>git fetch origin master:tmp</code>: 新建一个tmp分支，将远程仓库的master分支上代码版本复制到tmp分支上，不会自动合并<br><code>git merge 分支</code> : 指定分支合并到当前分支</p><ol start="3"><li><h6 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h6><p><code>git log</code>: 提交日志<br><code>git reflog</code>: 每次提交的ID<br><code>git reset --hard HEAD^</code>: 版本回退到一个版本，”^“回退一个版本，”^^”回退两个版本<br><code>git reset --hard ID号</code>:回退到指定版本</p></li><li><h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p><code>git rm 文件名</code>: 删除指定文件<br><code>git rm -r 文件名</code>: 删除指定文件夹<br><code>git rm --cached 文件</code>: 从暂存区删除 </p></li><li><h6 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h6></li></ol><p><code>git diff</code> : 比较暂存区与工作区<br><code>git diff --cached</code> : 比较版本区与暂存区<br><code>git diff master</code> : 比较版本区与工作区<br><code>git diff branch1 branch2</code>:显示出两个分支之间所有有差异的文件的详细差异<br><code>git diff branch1 branch2 --stat</code>:显示出两个分支之间所有有差异的文件列表<br><code>git diff branch1 branch2 xxx</code>:显示指定文件的详细差异</p><hr><h6 id="补充基础Linux命令"><a href="#补充基础Linux命令" class="headerlink" title="补充基础Linux命令"></a>补充基础Linux命令</h6><p><code>mkdir</code> :创建文件夹<br><code>vi</code> : 创建文件并进入<br><code>i</code> :编辑模式<br><code>ESC+:+wq</code> : 保存并退出<br><code>ESC+:+q!</code> : 不保存并退出<br><code>cd</code> : 进入文件夹<br><code>ls</code> : 当前文件夹文件列表<br><code>pwd</code> : 当前目录<br><code>cat</code> 文件 : 显示文件内容<br><code>clear</code> : 清屏</p><h6 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h6><ol><li>日常开发：feature =&gt; dev =&gt; test =&gt; master</li><li>紧急修复bug：master =&gt; hotfix =&gt; test =&gt; master</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue动态路由引入和异步组件记录</title>
      <link href="/2020/09/20/2-vue-router-dong-tai-lu-you/"/>
      <url>/2020/09/20/2-vue-router-dong-tai-lu-you/</url>
      
        <content type="html"><![CDATA[<p>动态引入的路由组件在打包时路由组件会被单独打包(代码分割 code split),<br>默认不请求加载路由组件打包文件, 当请求需要路由组件时才请求加载,当引入需要的的组件时在<code>Network</code>会增加一个打包文件(一般为<code>/^\d+.js$/</code>格式)。</p><h4 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h4><ul><li><p>component是一个执行就会<code>import()</code>的函数</p><pre><code>myComponent =  () =&gt; import(path)</code></pre></li><li><p>将组件定义对象(component definition)传递给 <code>resolve</code> 回调函数</p><pre><code>Vue.component(component, (resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve({      template: YourTemplate    })  }, 100)})</code></pre></li><li><p>使用<code>require</code>引入，这个特殊的 require 语法将指示 webpack 自动将构建后的代码，拆分到不同的 bundle 中，然后通过 Ajax 请求加载。</p><pre><code>Vue.component(component, (resolve) =&gt; {  setTimeOut(() =&gt; {    require(path, resolve);  }, 100)})</code></pre></li><li><p>使用返回的<code>promise</code>resolve前<code>import</code></p><pre><code>- Vue.component(component, (resolve) =&gt; {    setTimeOut(() =&gt; {      import(path).then(resolve);    }, 100)  })- Vue.component(component, Promise.resolve(template对象))- Vue.component(component, Promise.resolveDelay(template对象, time))</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>betterScroll踩坑记录</title>
      <link href="/2020/09/20/1-betterscroll-cai-keng-ji-lu/"/>
      <url>/2020/09/20/1-betterscroll-cai-keng-ji-lu/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用BetterScroll刚<code>npm run serve</code>时无法进行滑动，需要修改BetterScroll的源码，<br>   修改<code>BetterSC/shared-utils/src/dom.ts</code> 中的常量hasTouch为true,<br>   这样就可以在初始化时对参数进行设置,把一切掌握在自己手中</p><p>   使用方法如下:</p><pre><code> new BScroll时,在参数options中加入 mouseWheel: true,   //开启鼠标滚轮 disableMouse: false,   //启用鼠标拖动 disableTouch: false    //启用手指触摸</code></pre><p>   参考博客：<a href="https://www.cnblogs.com/mldonkey/p/11421577.html">https://www.cnblogs.com/mldonkey/p/11421577.html</a></p></li></ol><ol start="2"><li>使用BetterScroll后绑定scroll, click事件后无法触发，也无报错<br> BetterScroll默认拦截了click事件可在<code>new Bscroll()</code>的配置对象中传入<code> click: true</code></li><li>使用BetterScroll的<code>scroll</code>事件必须同时在<code>new Bscroll()</code>配置对象中指定<code>probeType</code> </li></ol><p><img src="/../images/1.1.jpg" alt="what"></p><p>(后面发现官网都有说明… 链接：<a href="https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F">https://better-scroll.github.io/docs/zh-CN/FAQ/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84-betterscroll-%E7%9B%91%E5%90%AC-scroll-%E9%92%A9%E5%AD%90%EF%BC%8C%E7%9B%91%E5%90%AC%E5%99%A8%E4%B8%8D%E6%89%A7%E8%A1%8C%EF%BC%9F</a>)</p><p><img src="/../images/1.2.jpg" alt="what"></p><p>. 使用better-scroll时注意$nextTick的使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
